

/*
//cool stuff we could try to achieve

#define COMPILER_MACRO

#assert false // assert in compile time maybe

*/

// Comment

/* Block comment */

/* /* Nested Block comment */ */

/* Multi
    /* Line
        /* Block comment */
    */
*/



delegate arithmetic : (a : int, b : int) -> int;


struct Person {
    name : string;
    age : int;
}

struct GenericPerson<T> {
    name : string;
    age : int;
    field : T; // ????
}

/*
struct Student : Person { // Inheritance?
    course : string;
}
*/

enum TYPES : int {
    TYPE_A = 0,
    TYPE_B = 1,
    TYPE_C = 2
}

enum TYPES : string {
    TYPE_A = 0,
    TYPE_B = 1,
    TYPE_C = 2
}



square : (int i) -> int {
	return i*i;
}



main() : void {

    p1 : Person;
    p2 := new Person;
    p1 = new Person {
        name = "Mike";
        age = 20;
    }
    
    delay print("Deleting p1"); // delay takes a statement and executes it at the very end of the block
    delay delete p1;

    delete p2; // Destructor

	a := square(2);
	b : int = square(a);

    

	mult : (int a, int b) -> int = (int a, int b) -> {
		return a * b;
	}

	div : arithmetic = (int a, int b) -> {
		return a / b;
	}

	sub:= (int a, int b) -> {
		return a - b;
	}

	sum := (int a, int b) -> a + b;

	sum2 : arithmetic = (a, b) -> a + b;
	
	
	
	
	
	i := 0;
	while (1) {
	
	    defer print(i);
	
	    if (i == 0) {
	        i ++;
	        continue;
	    }
	    else {
            i += 2;
            i = sum(i, square(i));
            
            if (i == 13)
                return;
                
            if (i > 300)
                break;
	    }
	    // defer print(i) will be called here
	}
	
	
	numbers := int[10];
	
	// Dynamic arrays?
	//results: int[];
	
	for (n in 0..count-1) {
	    print(numbers[n]);
	}
	
	for (i in numbers) {
	    print(i);
	}
	

}
